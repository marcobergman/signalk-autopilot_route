<!DOCTYPE html>
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Autopilot Route Follower</title>
    <script src="js/jquery-3.5.1.min.js"></script>
    <link rel="stylesheet" href="leaflet/leaflet.css"/>
    <script src="leaflet/leaflet.js"></script>
    <script src="leaflet/leaflet.rotatedMarker.js"></script>
    <style>
      body {
        padding: 0;
        margin: 0;
      }

      html, body, #map {
        height: 100%;
        width: 100%;
        z-index: 1;
        position: relative;
      }

      #map_container {
        height: 100%;
        width: 100%;
        z-index: 1;
        position: relative;
      }

      #controls {
        position: absolute;
        bottom: 50px;
        left: 50%;
        width: 300px;
        margin-left: -150px;
        z-index: 99;
        text-align: center;
        line-height: 40px;
      }
      
      #map_toggle {
        position: absolute;
        top: 20px;
        left: 50%;
        width: 300px;
        height: 50px;
        margin-left: -150px;
        z-index: 99;
        opacity: 1;
        border-radius: 5px;
        text-align: center;
        line-height: 40px;
      }

      #info {
        position: absolute;
        z-index: 110;
        top: 60px;
        left: 50%;
        padding: 5px;
        width: 400px;
        margin-left: -150px;
        height: 58px;
        overflow: none;
        background-color: black;
        border-radius: 10px;
        border: 1px solid #888;
        overflow-x: hidden;
        font-family: Verdana, Tahoma, sans-serif;
        font-size: 12pt;
      }

      #info .heading {
        font-weight: bold;
        text-align: center;
        font-size: 14pt;
      }

      #info .value {
        text-align: center;
        font-size: 13pt;
        margin-top: 5px;
      }

      .popupHeading {
        font-weight: bold;
        text-align: right;
      }

      button {
        padding: 10px;
        border-radius: 10px;
        border: 1px solid #888;
        background-color: white;
      }

      #anchorDown, #anchorUp {
        display: none;
      }
    </style>
</head>
<body>
<div id="map_container">
  <div id="map"></div>
  <div id="map_toggle">
  </div>
  <div id="controls">
  </div>
  <div id="info">
    <table style="width: 100%">
      <tr>
        <td style="width: 23%; color: blue">
          <div class="heading">
            <span>Leg</span>
          </div>
          <div class="value">
            <span id='segmentHeading'>-</span>째
          </div>
        </td>
        <td style="width: 15%; color: green">
          <div class="heading">
            Guide
          </div>
          <div class="value">
            <span id='guidePointBearing'>-</span>째
          </div>
        </td>
        <td style="width: 15%; color: Yellow">
          <div class="heading">
            Radius
          </div>
          <div class="value">
            <span id='guideRadiusValue'>-</span>m
          </div>
        </td>
        <td style="width: 15%; color: DeepPink">
          <div class="heading">
            MaxErr
          </div>
          <div class="value">
            <span id='maxErrorValue'>-</span>째
          </div>
        </td>
        <td style="width: 15%; color: DarkOrange">
          <div class="heading">
            Heading
          </div>
          <div class="value">
            <span id='headingValue'>-</span>째
          </div>
        </td>
        <td style="width: 15%; color: pink">
          <div class="heading">
            XTE
          </div>
          <div class="value">
            <span id='xteValue'></span>m
          </div>
        </td>
      </tr>
    </table>
 </div>
<script>
  var boat;
  var mmsi;
  var maxRadius;
  var latitude;
  var longitude;
  var target = {};
  var track;
  var route;
  var trackUpdater;
  var position;
  var heading;
  var speed;
  var drift;
  var courseData;
  var current;
  var routeVector;
  var guideVector;
  var guideCircle;
  var headingVector;
  var resultVector;

  // Check if we have an authenticated session first, if not, we will redirect
  // getTrack will return 401 if the session is not authenticated
  $.getJSON('/plugins/signalk-autopilot_route/getTrack', (data) => {
  }).fail((response) => {
    if (response.status = 401) {
      location.href="/admin/#/login";
    }
  });

  var map = L.map('map', {
    zoomControl: false
  }).setView([39.8283, -98.5795], 17);

  var targetIcon = L.icon({
    iconUrl: 'images/ais_boat.png',
    iconSize:     [24, 24], // size of the icon
    iconAnchor:   [12, 12], // point of the icon which will correspond to marker's location
  });

  var urlParams = new URLSearchParams(window.location.search);

  let bounds;

  setInterval( () => {
    // get boat position, speed and heading
    $.get('/signalk/v1/api/vessels/self/navigation', (data) => {
      position = data.position.value
      heading = data.headingTrue?.value;
      if (heading) {
        heading = heading *  57.295779513; // Convert to degrees
      } else {
        heading = 0;
      }
      let latlng = L.latLng(position.latitude, position.longitude);
      boat.setLatLng(latlng); 
      boat.setRotationAngle(heading);

      if (track) {
        track.addLatLng(latlng);
      }

      speed = data.speedThroughWater?.value
      if (speed) {
          speed = speed * 3600 / 1852; // knots
      } 
      $('#boatValue').html((0.0 + heading).toFixed(0)+'/'+(0.0 + speed).toFixed(1));
    });

    // get data
    $.getJSON('/plugins/signalk-autopilot_route/getData', (data) => {
      courseData = data;
    }); 

    // draw boat vectors
    if (courseData) {

	updateRoute(courseData.routePoints);

        line = [[courseData.previousPoint.latitude, courseData.previousPoint.longitude], [courseData.nextPoint.latitude, courseData.nextPoint.longitude]];
        if (routeVector) {
		routeVector.setLatLngs(line);
	} else {
		routeVector = L.polyline(line, {color: 'Blue', opacity: 1}).addTo(map);
        }

        line = [[courseData.currentPosition.latitude, courseData.currentPosition.longitude], [courseData.currentGuidePoint.latitude, courseData.currentGuidePoint.longitude]];
        if (guideVector) {
		guideVector.setLatLngs(line);
	} else {
		guideVector = L.polyline(line, {color: 'Green', opacity: 1, weight: 5}).addTo(map);
        }

        circleCenter = [ parseFloat(courseData.currentPosition.latitude), parseFloat(courseData.currentPosition.longitude)];
        if (guideCircle) {
		guideCircle.setLatLng(circleCenter);
	} else {
		guideCircle = L.circle(circleCenter, {radius: courseData.guideRadius, color: 'Yellow', opacity: 1}).addTo(map);
        }

        line = [[courseData.currentPosition.latitude, courseData.currentPosition.longitude], [courseData.headingPoint.latitude, courseData.headingPoint.longitude]];
        if (headingVector) {
		headingVector.setLatLngs(line);
	} else {
		headingVector = L.polyline(line, {color: 'DarkOrange', opacity: 1}).addTo(map);
        }

        $('#segmentHeading').html((0.0 + courseData.segmentHeading).toFixed(0));
        $('#guidePointBearing').html((0.0 + courseData.guidePointBearing).toFixed(0));
        $('#guideRadiusValue').html((0.0 + courseData.guideRadius).toFixed(0));
        $('#maxErrorValue').html((0.0 + courseData.maxErrorAngle).toFixed(0));
        $('#headingValue').html((0.0 + courseData.headingToSteer).toFixed(0));
        $('#xteValue').html(Math.abs(0.0 + courseData.xte * 1852).toFixed(0));
        map.setView([courseData.currentPosition.latitude, courseData.currentPosition.longitude]);
        if (bounds) {
           bounds.addLatLng({"lat": epLat + deltaLat, "lng": epLng + deltaLng});
	   map.fitBounds(bounds.getBounds());
        }
    }


    $.get('/signalk/v1/api/vessels/self/environment/depth/belowKeel/value', (depth) => {
      depth = Math.round(depth*10)/10;
      $('#depthValue').html(depth);
    }).fail(() => {
      $('#depthValue').html("~");
    });
	
  }, 1500);


  // Initial setup of icons etc.
  $.get('/signalk/v1/api/vessels/self', (data) => {
      mmsi = data.mmsi;
      let vesselType = data.design?.aisShipType?.value?.name;
      data = data.navigation;
      latitude = data.position.value.latitude;
      longitude = data.position.value.longitude;
      let heading = data.headingTrue?.value;
      if (heading) {
        heading = heading *  57.295779513; // Convert to degrees
      } else {
        heading = 0;
      }
      let latlng = L.latLng(latitude, longitude);
      zoom = 17;
      if (urlParams.has('zoom')) {
        zoom = urlParams.get('zoom');
      }
      map.setView(latlng, zoom);
      
      // Set boat icon
      let boatIcon = L.icon({
        iconUrl: vesselType === 'Sailing' ? 'images/sailboat.png' : 'images/powerboat.png',
        iconSize:     [24, 48], // size of the icon
        iconAnchor:   [12, 24], // point of the icon which will correspond to marker's location
      });
	  
      boat = L.marker(latlng, {
          rotationAngle: heading,
          icon: boatIcon
      }).addTo(map)
	  

  });

  satelliteLayer = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
    attribution: 'Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community',
    maxZoom: 19
  });

  osmLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    attribution: 'Map data from OpenStreetMap (OSM)',
    maxZoom: 19
  });
  osmLayer.addTo(map);

  openSeaMapLayer = L.tileLayer('http://tiles.openseamap.org/seamark/{z}/{x}/{y}.png', {
    attribution: 'Map data from OpenSeaMap',
    maxZoom: 19
  });
  openSeaMapLayer.addTo(map);

  var baseMaps = {
    "OpenStreetMap": osmLayer,
    "Satellite": satelliteLayer
  };

  var overlayMaps = {
    "OpenSeaMaps": openSeaMapLayer
  };	

  var layerControl = L.control.layers(baseMaps, overlayMaps, {
    position: 'bottomright'
  }).addTo(map);
  // On smaller screens for phones, layer control will be displayed in the center
  // This also supports a future app version of the plugin
  if (/iOS|iPhone|iPod|Android/.test(navigator.userAgent)) {
    var style = document.createElement('style');
    style.innerHTML = `
      .leaflet-control-layers-expanded {
        position: fixed !important;
        left: 50% !important;
        top: 50% !important;
        transform: translate(-50%, -50%) !important;
        z-index: 1000; /* Ensure it is above other elements */
      }
    `;
    document.head.appendChild(style);    
  }


  function updateTrack() {
    $.getJSON('/plugins/signalk-autopilot_route/getTrack', (data) => {
      const latLngs = data.map((item) => L.latLng(item.position.latitude, item.position.longitude));
      if (track) {
        track.setLatLngs(latLngs);
      } else {
        track = L.polyline(latLngs, {
          color: 'yellow',
          'opacity': 0.7,
          'weight': 1
        }).addTo(map);
      }
    });
  }


  function updateRoute(data) {
    var latLngs = []
    if (data) data.forEach((point) => {
       latLngs.push([point[1], point[0]])
    });

    if (route) {
      route.setLatLngs(latLngs);
    } else {
      route = L.polyline(latLngs, {
        color: 'blue'
      }).addTo(map);
    }
  }


  function calculateDistance(lat1, lon1, lat2, lon2) {
    var R = 6371000; // Radius of the earth in m
    var dLat = deg2rad(lat2-lat1);  // deg2rad below
    var dLon = deg2rad(lon2-lon1);
    var a =
      Math.sin(dLat/2) * Math.sin(dLat/2) +
      Math.cos(deg2rad(lat1)) * Math.cos(deg2rad(lat2)) *
      Math.sin(dLon/2) * Math.sin(dLon/2)
      ;
    var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    var d = R * c; // Distance in km
    return d;
  }

  function deg2rad(deg) {
    return deg * (Math.PI/180)
  }
</script>
</body>
</html>
